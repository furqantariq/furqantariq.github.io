<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Raycasting - part 1 | amoebatron</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Raycasting - part 1" />
<meta name="author" content="Furqan" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction" />
<meta property="og:description" content="Introduction" />
<link rel="canonical" href="http://localhost:4000/2023/06/04/raycasting1.html" />
<meta property="og:url" content="http://localhost:4000/2023/06/04/raycasting1.html" />
<meta property="og:site_name" content="amoebatron" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-06-04T20:47:30+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Raycasting - part 1" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Furqan"},"dateModified":"2023-06-04T20:47:30+02:00","datePublished":"2023-06-04T20:47:30+02:00","description":"Introduction","headline":"Raycasting - part 1","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/06/04/raycasting1.html"},"url":"http://localhost:4000/2023/06/04/raycasting1.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="amoebatron" />


<link rel="apple-touch-icon" sizes="120x120" href="/assets/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/favicons/site.webmanifest">
<link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/assets/favicons/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">

<meta property="og:image" content="https://furqantariq.github.io/assets/img/share.gif">
<meta property="og:image:height" content="335">
<meta property="og:image:width" content="640">
<meta property="og:title" content="amoebatron's personal blog">
<meta property="og:description" content="">
<meta property="og:url" content="https://furqantariq.github.io">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<script>
MathJax = {
  tex: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEnvironments: true
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>


</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">amoebatron</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/twitch/">Twitch</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Raycasting - part 1</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-06-04T20:47:30+02:00" itemprop="datePublished">
        Jun 4, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>

<p>Raycasting is a technique in Computer Graphics to create three-dimensional (3D) perspective image from two-dimensional 
(2D) data. Back in the days, when game development was in its nascency and computer were slow with limited memory, 
it was one of the efficient ways to create scenes from a player’s perspective. It gained prominence in games like 
<a href="https://en.wikipedia.org/wiki/Wolfenstein_3D">Wolfenstein 3D</a> and <a href="https://en.wikipedia.org/wiki/Doom_(franchise)">Doom</a>
which also happened to introduce the concept of <a href="https://en.wikipedia.org/wiki/First-person_shooter">first-person-shooter</a> 
(FPS) games.</p>

<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/561sPCk6ByE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</center>

<h2 id="raycasting-algorithm">Raycasting Algorithm</h2>

<h3 id="data-representation">Data Representation</h3>

<p>Before delving into implementation of raycasting, we have to define our game world data in 2D-matrix in which 
each element corresponds to square cell in the game world with a height, width and breadth of $\textit{cellsize}$. 
The value “<strong>1</strong>” represents that this cell is a wall and “<strong>0</strong>” represents an empty space where player can move. 
In the figure below, the player $P$ is standing at $x=2.5, y=0.5$ position and he is looking toward wall with an 
direction angle $P_\theta$ of 90 degrees. The fraction part of the position indicates that player is standing in the middle of cell. 
The player also has a <a href="https://en.wikipedia.org/wiki/Field_of_view">Field of View</a> (FOV) angle that represents the total observable area that can be seen at once by 
player’s eye.</p>

\[map (x, y) = 
    \begin{bmatrix}
        0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 
        1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\
        0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    \end{bmatrix}\]

\[FOV = 70^\circ\]

\[P_{x,y} = (2.5, 0.5), P_\theta = 90^\circ\]

<center><img src="/assets/images/raycasting/map.svg" width="60%" height="60%" /></center>

<h3 id="casting-rays">Casting Rays</h3>
<p>In principle, raycasting works by projecting rays from players position across his field of view and tracing them to 
the point where they intersect with wall, object or nothing. The number of rays that are casted are equal to the width 
of the screen because each ray is responsible for drawing to its respective column of pixels in the projected screen. 
After finding intersection points, the distance between the player position and each intersection point is calculated and 
based on that distance object or wall is drawn into respective column. Objects that are closer to the camera will appear larger, 
while those farther away will appear smaller, simulating depth perception.</p>

<center><img src="/assets/images/raycasting/rays.svg" width="90%" height="90%" /></center>
<center><img src="/assets/images/raycasting/perspective.svg" width="90%" height="90%" /></center>

<h3 id="ray-object-intersection">Ray-Object intersection</h3>

<p>Each ray $R_i$ originates from the player position $P_{x,y}$ with an angle $\theta_i$ and before casting rays, 
their angles must be determined first. Since we know that number of rays are equal to the screen width, 
then the angle between two consective rays will be $ \frac{FOV}{\textit{screen-width}} $ and left most ray $R_0$ will have an angle
$ \theta_0 = P_\theta + \frac{FOV}{2} $ so the angle of $i$th ray would be</p>

\[\theta_i = (P_\theta + \frac{FOV}{2}) - i\cdot(\frac{FOV}{\textit{screen-width}})\]

<p>The tracing of rays involves finding all the horizontal and vertical gridlines of the map that particular ray $R_i$
falls on. On each horizontal gridline we check whether next horizontal cell infront of ray is wall or not and on 
each vertical gridline we check the same but with vertical cells. If we encounter any cell or wall then 
we stop at that point and that point is our intersection point $V_{i_{x,y}}$ or $H_{i_{x,y}}$ for ray $R_i$. During tracing, if we dont encounter any object and 
reach end of the map then we consider our distance to be infinite.</p>

<p>Since player $P_{x,y}$ standing somewhere inside the cell, so we have to find the nearby horizontal $h_{i_{x,y}}$ and 
vertical $v_{i_{x,y}}$ gridline and that we can find by taking difference between $\textit{cellsize}$ and player position 
$P_{x,y}$, depending on the direction of the ray $R_i$ (i.e. we have to move backward if $\theta_i \ge 180^\circ$). 
The directional part can easily be fixed by just multiplying it with sign value of $\cos\theta_i$ (in case of horizontal) and $\sin\theta_i$ (in case of vertical).</p>

<p>The corresponding component can be calculated by the trigonometric ratio $ \tan\theta = \frac{\text{perpendicular}}{\text{base}} $.</p>

\[\begin{align}
h_x &amp;= \frac{\cos\theta_i}{|\cos\theta_i|}\cdot(cellsize - P_x) \\[2ex] 
h_y &amp;= h_x\cdot\tan\theta_i \\ 
\end{align}\]

<p>similarly for vertical gridlines,</p>

\[\begin{align}
v_y &amp;= \frac{\sin\theta_i}{|\sin\theta_i|}\cdot(cellsize-P_y)\\[2ex] 
v_x &amp;= \frac{v_y}{\tan\theta_i} \\
\end{align}\]

<p>After finding initial gridline points, now its time to move to the next gridline points along the ray $R_i$.
For this, we can a define a <a href="https://www.khanacademy.org/math/algebra/x2f8bb11595b61c86:sequences/x2f8bb11595b61c86:constructing-arithmetic-sequences/a/writing-recursive-formulas-for-arithmetic-sequences">recursive</a>
function $\textit{next-grid}(x,y)$ that jumps to next gridline point by adding $\textit{cellsize}$
to the respective component and stops when it encounters an object.</p>

\[\textit{next-grid-h} (x, y) = 
\begin{cases}
(x, y), &amp; \textit{if map$( \lfloor\frac{x}{cellsize}\rfloor + \frac{\cos\theta_i}{|\cos\theta_i|}, \lfloor\frac{y}{cellsize}\rfloor) = 1$} \\[2ex]
\textit{next-grid-h}(\underbrace{x + \frac{\cos\theta_i}{|\cos\theta_i|}\cdot cellsize}_\acute{x}, \acute{x}\cdot\tan\theta_i), &amp; \text{else} \\
\end{cases}\]

<p>similarly,</p>

\[\textit{next-grid-v}(x,y) = 
\begin{cases}
(x, y), &amp;\textit{if map$( \lfloor\frac{x}{cellsize}\rfloor, \lfloor\frac{y}{cell size}\rfloor  + \frac{\sin\theta_i}{|\sin\theta_i|}),= 1$} \\[2ex]
\textit{next-grid-v}(\frac{\acute{y}}{\tan{\theta_i}}, \underbrace{y + \frac{\sin\theta_i}{|\sin\theta_i|}\cdot cellsize}_{\acute{y}}), &amp; \textit{else} \\
\end{cases}\]

<p>The pictorial form of ray-object intersection can also be seen below.</p>

<center><img src="/assets/images/raycasting/raytracing.svg" width="90%" height="90%" /></center>

<p>So the intersection points $H_{i_{x,y}}$ and $V_{i_{x,y}}$ that intersects ray will be</p>

\[H_{i_{x,y}} = \textit{next-grid-h}(h_{i_{x,y}})\]

\[V_{i_{x,y}} = \textit{next-grid-v}(v_{i_{x,y}})\]

<p>where $h_{i_{x,y}}$ and $v_{i_{x,y}}$ are nearby gridline points for any $R_i$</p>

<p>Between these two intersection points, only the nearest point will be used in scene rendering because the farthest point
will always be hidden behind. The intersection point itself has no value for us unless we are applying textures, 
but we are interested in the distance to nearest intersection point. This can be found by taking minimum of the 
<a href="https://en.wikipedia.org/wiki/Euclidean_distance">euclidean distances</a> from player position $P_{x,y}$ to both of these points $H_{x,y}$ and $V_{x,y}$</p>

\[\acute{d_i} = \min(\sqrt{ (P_x - H_{i_x} )^2 + (P_y - H_{i_y})^2} ,  \sqrt{ (P_x - V_{i_x} )^2 + (P_y - V_{i_y})^2})\]

<h3 id="fixing-fisheye-lens">Fixing Fisheye-Lens</h3>

<p>Although we have distance now but the distance is not correct and it is actually slightly distorted. If we use this
distance in drawing our scene, It will give an effect known as <a href="https://en.wikipedia.org/wiki/Fisheye_lens">“fisheye effect”</a>. The reason behind is because the rays
that are away from the player direction are actually longer in length then the rays that are parallel to player direction
and these longer rays give an illusion that object is farther away, hence the fisheye
effect. To fix that is quite simple, all we have to do is multiply distorted distance with cosine of abosulte difference of
ray angle $\theta_i$ and player direction $P_\theta$.</p>

<center><img src="/assets/images/raycasting/fishbowl-effect.svg" width="90%" height="90%" /></center>

\[d_i = \acute{d_i} \cdot \cos(|\theta_i-P_\theta|)\]

<h3 id="projection">Projection</h3>

<p>The purpose of finding distance to object was to find out the projected height of the object. We have already
established earlier that everything player see is of same height. Now if we look at the figure below,
the actual object lies at distance $\overline{OF}$ away from player $P$ with height $\overline{AB}$ and the line $\overline{XY}$ 
represents the projected height of the object in projection screen, that also lies at certain distance $\overline{OD}$ 
away from player $P$ in same direction. This gives us two <a href="https://byjus.com/maths/similar-triangles/">similar triangles</a> $ \triangle AOB $ and $ \triangle XOY $ with 
equal angles that means the ratios of their corresponding sides are equal.</p>

<center><img src="/assets/images/raycasting/triangles.svg" width="90%" height="90%" /></center>

\[\triangle AOB \sim \triangle XOY\]

\[\frac{\overline{XY}}{\overline{AB}} = \frac{\overline{DO}}{\overline{FO}}\]

<p>Since $\overline{AB}$ is $\textit{cellsize}$, $\overline{FO}$ is the distance we calculated earler and $\overline{OD}$ is 
upto us to decide how much away projection screen from player $P$ should be, that leave us $\overline{XY}$ which is 
the projected height $h_i$ of the object with which the ray $R_i$ intersects.</p>

\[h_i = \frac{cellsize}{d_i} \cdot \textit{projection-distance}\]

<h3 id="rendering-scene">Rendering Scene</h3>

<p>To render final scene, raycasting uses column-based rendering. In which we iterates through each column $c_i$ in screen 
and at the center of the pixel column, we fills all corresponding pixels with color of object that intersects with ray $R_i$ 
at the calculated projected height $h_i$. In each iteration, rest of the pixels are filled with environment color
e.g. sky, floor … etc.</p>

<center><img src="/assets/images/raycasting/rendering.svg" width="90%" height="90%" /></center>

<p>In the end, after rendering process, we will have a 2D image that represents a 3D scene with illusion of depth and 
object visibility from 2D data, the demonstration of which can be seen below.</p>

<h1 id="demo">Demo</h1>

<p>Use <strong>W</strong>,<strong>A</strong>,<strong>S</strong> and <strong>D</strong> keys to update $P_{x,y}$ and modify $P_\theta$ with mouse pointer.</p>

<p>Readers are encouraged to open ‘Typescript’ tab and to experiment with different colors, <code class="language-plaintext highlighter-rouge">WORLD_MAP</code> variable and various
other configurable variables.</p>

<center><iframe height="570" style="width: 100%;" scrolling="no" title="Raycasting" src="https://codepen.io/furqant/embed/XWPRyYv?default-tab=result&amp;editable=true&amp;theme-id=light" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/furqant/pen/XWPRyYv">
  Raycasting</a> by Furqan (<a href="https://codepen.io/furqant">@furqant</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe></center>

<p><em>This blogpost will be divided into two parts and in next part i will write about applying textures and implementing 
weather effects (fog, night and day) using raycasting</em></p>

  </div><a class="u-url" href="/2023/06/04/raycasting1.html" hidden></a>
</article>

      </div>
    </main>
</body>

</html>
